/**
 * IndexedDB Lite - A small, team-usable IndexedDB wrapper library
 * File: indexeddb-lite.js
 * Author: Generated by ChatGPT
 * License: MIT
 *
 * Features:
 * - Promisified API for open / close / transactions
 * - Automatic migrations (onupgradeneeded handler)
 * - Create / read / update / delete (CRUD)
 * - Bulk operations (bulkAdd, bulkPut, bulkDelete)
 * - getAll, getAllKeys, count
 * - Cursors + iterate
 * - Index helpers (create, query by index)
 * - Export / Import (JSON snapshot of stores)
 * - TTL support via a special index and cleanup method
 * - Optional hooks (before/after operations)
 * - Graceful error handling, retries
 * - UMD + ESM export
 *
 * Usage examples at bottom of file.
 */

(function (global, factory) {
  if (typeof module === "object" && typeof module.exports === "object") {
    module.exports = factory();
  } else if (typeof define === "function" && define.amd) {
    define([], factory);
  } else {
    global.IDBLight = factory();
  }
})(typeof window !== "undefined" ? window : this, function () {
  "use strict";

  /**
   * Small helper: promisify a request
   * @param {IDBRequest} req
   * @returns {Promise<any>}
   */
  function promisifyRequest(req) {
    return new Promise((resolve, reject) => {
      req.onsuccess = () => resolve(req.result);
      req.onerror = () => reject(req.error);
    });
  }

  /**
   * Helper to wait for transaction completion
   * @param {IDBTransaction} tx
   * @returns {Promise<void>}
   */
  function txComplete(tx) {
    return new Promise((resolve, reject) => {
      tx.oncomplete = () => resolve();
      tx.onabort = () => reject(tx.error || new Error("Transaction aborted"));
      tx.onerror = () => reject(tx.error || new Error("Transaction error"));
    });
  }

  /**
   * Default retry wrapper for transient errors
   */
  async function withRetries(fn, retries = 2, delay = 100) {
    let lastErr;
    for (let i = 0; i <= retries; i++) {
      try {
        return await fn();
      } catch (e) {
        lastErr = e;
        if (i < retries) await new Promise((r) => setTimeout(r, delay));
      }
    }
    throw lastErr;
  }

  /**
   * IDBLight class
   * @class
   */
  class IDBLight {
    /**
     * Create an instance
     * @param {Object} options
     * @param {string} options.dbName
     * @param {number} [options.version=1]
     * @param {Object[]} [options.stores] - List of store definitions for schema/migrations
     *   Each store: { name: 'users', options: { keyPath: 'id', autoIncrement: false }, indexes: [{ name: 'byEmail', keyPath: 'email', options: { unique: true } }] }
     * @param {Function} [options.migrations] - optional function(db, oldVersion, newVersion) for custom migrations
     * @param {boolean} [options.debug=false]
     */
    constructor({
      dbName,
      version = 1,
      stores = [],
      migrations = null,
      debug = false,
    } = {}) {
      if (!dbName) throw new Error("dbName is required");
      this.dbName = dbName;
      this.version = version;
      this.stores = stores;
      this._db = null;
      this._openReq = null;
      this.migrations = migrations;
      this.debug = debug;
      this.hooks = {
        beforeAdd: null,
        afterAdd: null,
        beforePut: null,
        afterPut: null,
        beforeDelete: null,
        afterDelete: null,
      };
    }

    _log(...args) {
      if (this.debug) console.log("[IDBLight]", ...args);
    }

    /**
     * Open the database (or reuse existing connection)
     * @returns {Promise<IDBDatabase>}
     */
    open() {
      if (this._db) return Promise.resolve(this._db);
      if (this._openReq) return this._openReq;

      this._openReq = new Promise((resolve, reject) => {
        const req = indexedDB.open(this.dbName, this.version);

        req.onupgradeneeded = (e) => {
          const db = e.target.result;
          const oldV = e.oldVersion;
          const newV = e.newVersion;

          this._log("onupgradeneeded", oldV, "->", newV);

          // Create/upgrade stores based on this.stores array
          for (const st of this.stores) {
            if (!db.objectStoreNames.contains(st.name)) {
              const store = db.createObjectStore(
                st.name,
                st.options || { keyPath: "id" }
              );
              if (st.indexes && Array.isArray(st.indexes)) {
                for (const idx of st.indexes) {
                  store.createIndex(idx.name, idx.keyPath, idx.options || {});
                }
              }
            } else {
              // optionally ensure indexes exist
              const store = req.transaction.objectStore(st.name);
              if (st.indexes && Array.isArray(st.indexes)) {
                for (const idx of st.indexes) {
                  if (!store.indexNames.contains(idx.name)) {
                    store.createIndex(idx.name, idx.keyPath, idx.options || {});
                  }
                }
              }
            }
          }

          // custom migrations
          if (typeof this.migrations === "function") {
            try {
              this.migrations(db, oldV, newV);
            } catch (err) {
              console.error("Migration function threw", err);
            }
          }
        };

        req.onsuccess = (e) => {
          this._db = e.target.result;

          // wire close event
          this._db.onversionchange = () => {
            this._log("Database version change detected â€” closing connection");
            this._db.close();
            this._db = null;
          };

          resolve(this._db);
        };

        req.onerror = (e) =>
          reject(e.target.error || new Error("Failed to open DB"));
      });

      return this._openReq;
    }

    /**
     * Close DB connection
     */
    close() {
      if (this._db) {
        try {
          this._db.close();
        } finally {
          this._db = null;
        }
      }
    }

    /**
     * Ensure store exists (helper). Throws if missing.
     * @param {string} storeName
     */
    _ensureStore(storeName) {
      if (!this._db) throw new Error("DB not opened");
      if (!this._db.objectStoreNames.contains(storeName)) {
        throw new Error(`Object store "${storeName}" not found`);
      }
    }

    /**
     * Run a transaction with given mode and store names
     * @param {string[]} stores
     * @param {'readonly'|'readwrite'} mode
     * @param {(tx: IDBTransaction) => any} callback
     */
    async transaction(stores, mode, callback) {
      const db = await this.open();
      const tx = db.transaction(stores, mode);
      try {
        const result = callback(tx);
        await txComplete(tx);
        return result;
      } catch (err) {
        tx.abort();
        throw err;
      }
    }

    /**
     * Add an item to a store
     * @param {string} storeName
     * @param {any} item
     * @returns {Promise<any>} inserted key/result
     */
    async add(storeName, item) {
      return withRetries(async () => {
        const db = await this.open();
        this._ensureStore(storeName);
        return new Promise((resolve, reject) => {
          const tx = db.transaction([storeName], "readwrite");
          const store = tx.objectStore(storeName);

          try {
            if (this.hooks.beforeAdd) this.hooks.beforeAdd(item, storeName);
          } catch (e) {
            console.warn("beforeAdd hook error", e);
          }

          const req = store.add(item);
          req.onsuccess = (e) => resolve(e.target.result);
          req.onerror = (e) => reject(e.target.error);

          tx.oncomplete = () => {
            try {
              if (this.hooks.afterAdd) this.hooks.afterAdd(item, storeName);
            } catch (e) {
              console.warn("afterAdd hook error", e);
            }
          };
        });
      });
    }

    /**
     * Put (add or update) an item
     * @param {string} storeName
     * @param {any} item
     * @returns {Promise<any>} key
     */
    async put(storeName, item) {
      return withRetries(async () => {
        const db = await this.open();
        this._ensureStore(storeName);
        return new Promise((resolve, reject) => {
          const tx = db.transaction([storeName], "readwrite");
          const store = tx.objectStore(storeName);

          try {
            if (this.hooks.beforePut) this.hooks.beforePut(item, storeName);
          } catch (e) {
            console.warn("beforePut hook error", e);
          }

          const req = store.put(item);
          req.onsuccess = (e) => resolve(e.target.result);
          req.onerror = (e) => reject(e.target.error);

          tx.oncomplete = () => {
            try {
              if (this.hooks.afterPut) this.hooks.afterPut(item, storeName);
            } catch (e) {
              console.warn("afterPut hook error", e);
            }
          };
        });
      });
    }

    /**
     * Get item by key
     * @param {string} storeName
     * @param {any} key
     * @returns {Promise<any>}
     */
    async get(storeName, key) {
      const db = await this.open();
      this._ensureStore(storeName);
      const tx = db.transaction([storeName], "readonly");
      const store = tx.objectStore(storeName);
      const req = store.get(key);
      return promisifyRequest(req);
    }

    /**
     * getAll
     * @param {string} storeName
     * @param {IDBKeyRange|any} [query]
     * @param {number} [count]
     */
    async getAll(storeName, query, count) {
      const db = await this.open();
      this._ensureStore(storeName);
      const tx = db.transaction([storeName], "readonly");
      const store = tx.objectStore(storeName);
      const req = store.getAll(query, count);
      return promisifyRequest(req);
    }

    /**
     * getAllKeys
     */
    async getAllKeys(storeName, query, count) {
      const db = await this.open();
      this._ensureStore(storeName);
      const tx = db.transaction([storeName], "readonly");
      const store = tx.objectStore(storeName);
      const req = store.getAllKeys(query, count);
      return promisifyRequest(req);
    }

    /**
     * Delete
     */
    async delete(storeName, key) {
      return withRetries(async () => {
        const db = await this.open();
        this._ensureStore(storeName);
        return new Promise((resolve, reject) => {
          const tx = db.transaction([storeName], "readwrite");
          const store = tx.objectStore(storeName);

          try {
            if (this.hooks.beforeDelete)
              this.hooks.beforeDelete(key, storeName);
          } catch (e) {
            console.warn("beforeDelete hook error", e);
          }

          const req = store.delete(key);
          req.onsuccess = () => resolve(true);
          req.onerror = (e) => reject(e.target.error);

          tx.oncomplete = () => {
            try {
              if (this.hooks.afterDelete)
                this.hooks.afterDelete(key, storeName);
            } catch (e) {
              console.warn("afterDelete hook error", e);
            }
          };
        });
      });
    }

    /**
     * Clear a store
     */
    async clear(storeName) {
      const db = await this.open();
      this._ensureStore(storeName);
      const tx = db.transaction([storeName], "readwrite");
      const store = tx.objectStore(storeName);
      const req = store.clear();
      await promisifyRequest(req);
      await txComplete(tx);
      return true;
    }

    /**
     * Count items
     */
    async count(storeName, query) {
      const db = await this.open();
      this._ensureStore(storeName);
      const tx = db.transaction([storeName], "readonly");
      const store = tx.objectStore(storeName);
      const req = store.count(query);
      return promisifyRequest(req);
    }

    /**
     * Bulk add
     */
    async bulkAdd(storeName, items) {
      if (!Array.isArray(items)) throw new Error("items must be an array");
      const db = await this.open();
      this._ensureStore(storeName);
      const tx = db.transaction([storeName], "readwrite");
      const store = tx.objectStore(storeName);
      for (const item of items) store.add(item);
      await txComplete(tx);
      return items.length;
    }

    /**
     * Bulk put
     */
    async bulkPut(storeName, items) {
      if (!Array.isArray(items)) throw new Error("items must be an array");
      const db = await this.open();
      this._ensureStore(storeName);
      const tx = db.transaction([storeName], "readwrite");
      const store = tx.objectStore(storeName);
      for (const item of items) store.put(item);
      await txComplete(tx);
      return items.length;
    }

    /**
     * Bulk delete by keys array
     */
    async bulkDelete(storeName, keys) {
      if (!Array.isArray(keys)) throw new Error("keys must be an array");
      const db = await this.open();
      this._ensureStore(storeName);
      const tx = db.transaction([storeName], "readwrite");
      const store = tx.objectStore(storeName);
      for (const key of keys) store.delete(key);
      await txComplete(tx);
      return keys.length;
    }

    /**
     * Iterate with cursor
     * @param {string} storeName
     * @param {(cursor: IDBCursorWithValue) => void} onCursor
     * @param {'next'|'nextunique'|'prev'|'prevunique'} [direction='next']
     * @returns {Promise<void>}
     */
    async iterate(storeName, onCursor, direction = "next") {
      const db = await this.open();
      this._ensureStore(storeName);
      return new Promise((resolve, reject) => {
        const tx = db.transaction([storeName], "readonly");
        const store = tx.objectStore(storeName);
        const req = store.openCursor(null, direction);
        req.onsuccess = (e) => {
          const cursor = e.target.result;
          if (cursor) {
            try {
              onCursor(cursor);
            } catch (err) {
              return reject(err);
            }
            cursor.continue();
          }
        };
        req.onerror = (e) => reject(e.target.error);
        tx.oncomplete = () => resolve();
      });
    }

    /**
     * Query by index
     * @param {string} storeName
     * @param {string} indexName
     * @param {any} query
     */
    async getByIndex(storeName, indexName, query) {
      const db = await this.open();
      this._ensureStore(storeName);
      const tx = db.transaction([storeName], "readonly");
      const store = tx.objectStore(storeName);
      const idx = store.index(indexName);
      const req = idx.getAll(query);
      return promisifyRequest(req);
    }

    /**
     * Export DB snapshot (selected stores) to JSON
     * @param {string[]} [storeNames] - default all
     */
    async export(storeNames) {
      const db = await this.open();
      const names = storeNames || Array.from(db.objectStoreNames);
      const snapshot = {};
      for (const name of names) {
        snapshot[name] = await this.getAll(name);
      }
      return snapshot;
    }

    /**
     * Import snapshot (replace store contents)
     * @param {Object} snapshot - { storeName: [records] }
     * @param {boolean} [clearFirst=true]
     */
    async import(snapshot, clearFirst = true) {
      const db = await this.open();
      const names = Object.keys(snapshot || {});
      for (const name of names) {
        if (!db.objectStoreNames.contains(name)) continue;
        const tx = db.transaction([name], "readwrite");
        const store = tx.objectStore(name);
        if (clearFirst) store.clear();
        for (const rec of snapshot[name]) store.put(rec);
        await txComplete(tx);
      }
      return true;
    }

    /**
     * Simple TTL cleanup: assumes items have a numeric field ttl (epoch ms) or _expires
     * Use store index on that field for efficient cleanup.
     * @param {string} storeName
     * @param {string} fieldName - field containing expiry time (e.g. '_expires')
     */
    async cleanupExpired(storeName, fieldName = "_expires") {
      const now = Date.now();
      await this.iterate(storeName, (cursor) => {
        const val = cursor.value;
        if (val && val[fieldName] && val[fieldName] <= now) cursor.delete();
      });
    }

    /**
     * Create a store dynamically (only works when DB is opened with version bump)
     * NOTE: To add stores at runtime you must close the DB and re-open with higher version
     * @param {string} storeName
     * @param {Object} options
     * @param {Array} indexes
     */
    async createStore(storeName, options = { keyPath: "id" }, indexes = []) {
      // Close DB and reopen with incremented version
      this.close();
      this.version = (this.version || 1) + 1;
      this.stores.push({ name: storeName, options, indexes });
      await this.open();
      return true;
    }

    /**
     * Delete a database entirely
     * @returns {Promise<void>}
     */
    async deleteDatabase() {
      this.close();
      return new Promise((resolve, reject) => {
        const req = indexedDB.deleteDatabase(this.dbName);
        req.onsuccess = () => resolve();
        req.onerror = (e) => reject(e.target.error);
        req.onblocked = () => console.warn("deleteDatabase blocked");
      });
    }

    /**
     * Small util: open transaction and return objectStore
     * @param {string} storeName
     * @param {'readonly'|'readwrite'} mode
     */
    async storeTx(storeName, mode = "readonly") {
      const db = await this.open();
      this._ensureStore(storeName);
      const tx = db.transaction([storeName], mode);
      return { tx, store: tx.objectStore(storeName) };
    }
  }

  // default export
  return IDBLight;
});

/*************************************
 * Usage Examples
 *************************************/

/*
Example 1 - Basic usage (plain JS):

const IDBLight = window.IDBLight;
const db = new IDBLight({
  dbName: 'teamDB',
  version: 1,
  debug: true,
  stores: [
    { name: 'users', options: { keyPath: 'id' }, indexes: [{ name: 'byEmail', keyPath: 'email', options: { unique: true } }] },
    { name: 'notes', options: { keyPath: 'id', autoIncrement: true }, indexes: [{ name: 'byUser', keyPath: 'userId' }] }
  ]
});

(async () => {
  await db.open();
  await db.add('users', { id: 'u1', name: 'Amit', email: 'amit@example.com' });
  await db.put('notes', { userId: 'u1', content: 'Hello world', _expires: Date.now() + 1000 * 60 * 60 * 24 });
  const users = await db.getAll('users');
  console.log(users);
  await db.cleanupExpired('notes');
  const snap = await db.export();
  console.log(JSON.stringify(snap));
})();

Example 2 - React (simple hook)

import IDBLight from './indexeddb-lite.js';
const db = new IDBLight({ dbName: 'teamDB', version: 1, stores: [{ name: 'tasks', options: { keyPath: 'id' } }] });

// useEffect(() => { db.open(); }, []);
// then call db.add/put/getAll inside your components

Example 3 - Import/export

const snapshot = await db.export();
// save snapshot to server or file
await db.import(snapshot);

*/
